---
title: "Cobs Tidy Script"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading data and setting working directory
```{r}
install.packages(c("dplyr" , "ggplot2"))
getwd()
cobs_data<- read.csv("data/KBase_MGRast_Metadata_9May2013_EMB.csv", stringsAsFactors = FALSE)
```

## loading necessary libraries
```{r}
library(tidyverse)
library(stringi)
```

## changing heading names 
```{r}
colnames(cobs_data)<-c("sample_Id" , "sample_month" , "sample_year" , "crop" , "sample_block" , "agg_frac" , "MGRAST_Id" , "agrochem_addition" , "crop_rot" , "land_use" , "veg_class" , "veg_class_meth" , "drain_class" , "extreme_event" , "FAO_class" , "fire_hist" , "soil_hor" , "soil_hor_meth" , "link_soil_method" , "soil_tax" , "soil_tax_meth" , "MGRAST_Id" , "micro_bm" , "micro_bm_meth" , "misc_param" , "pH" , "pH_meth" , "dna_mix" , "land_use_pre" , "land_use_pre_meth" , "sample_position" , "salinity_meth" , "sample_wt_dna" , "siev_size" , "slope_aspect" , "slope_grad" , "soil_type" , "soil_type_meth" , "store_cond" , "texture" , "texture_meth" , "till" , "total_N" , "total_N_meth" , "total_OC_meth" , "total_OC" , "soil_water" , "soil_water_meth" , "total_C" , "misc_param_1" , "MBN_dry" , "MBN_applied" , "Ext_C_dry" , "Ext_C_applied" , "Ext_C_N_dry" , "Ext_N_applied" , "Bulk_dense" , "Ext_P_dry" , "AMF_col" , "AP_act" , "BG_act" , "BX_act" , "CB_act" , "NAG_act" , "Sum_C_act" , "MBC_dry" , "MBC_applied" , "MBC_MBN_meth" , "Ext_C_Ext_N_meth" , "AMF_col_meth" , "root_bm" , "root_dep" , "AMF_col_bm" , "MBC:MBN" , "MWD" , "agg_frac_prop" , "N2O_2011" , "CH4_2011" , "N2O_2012" , "CO2_2011" , "CO2_2012")

```
In order to make the data more human-friendly, I changed the heading names.  They are all now in a similar form and are more intuitive.  These are the heading names which will be used within the data dictionary.

## removing duplicate column & first row
```{r}
to_remove <- names(which(table(names(cobs_data)) > 1))
cobs_updated <- cobs_data[-1, !(to_remove == names(cobs_data))]
```
After preparing the data with better-suited header names, the next step was to delete any columns which were repeated.  Tidy data does not include duplicate columns.  There were two columns which had the exact same data repeated, and those were eliminated.  Secondly, the first row was deleted, as it did not contain any data, just a description of the header.  This was addressed in the separate data dictionary document, and so was unnecessary within the data set.

## summary to find blank/null columns
```{r}
summary(cobs_updated)
table(cobs_updated$total_OC_meth)

empty <- numeric(0)
for(i in 1:ncol(cobs_updated)){
  if(sum(cobs_updated[, i] == "") == nrow(cobs_updated)) {
   empty <- c(empty, i)
  }
}
subset_cobs <- select(cobs_updated, -empty)
```
By looking at the raw data, I could tell there were a few columns which did not contain any data.  In order to tidy the data set,  I wanted to delete these.  By using the summarize function, and also creating a subset "empty" to house all columns which fit my description (no data values), I was able to subset the data by selecting only the columns which were not included in "empty", leaving only columns with values.

## parsing columns
```{r}
parsed_cobs <- subset_cobs %>%
  separate("texture", into = c("sand", "silt", "clay"), sep=",") %>%
  separate(sample_Id, into = c("plot_treatment", "agg_fraction", "date"), sep="-") 
```
There were two columns within the data set which held multiple pieces of information, able to be split into individual columns.  Soil "texture" held percentages for sand, silt, and clay, so I placed each value in its own column.  Secondly, the column "sample Id" contained three different categories of information.  This was divided into plot treatment, aggregate fraction, and date for easier use in analysis.

## Deleting after parsing
```{r}
parsed_cobs[2:3]<- list(NULL)
```
After splitting the columns into individual pieces, it was necessary to delete those which now repeated information.  The plot treatment and date became columns with repeated data, so they were deleted.

## splitting column with regex
```{r}
library(stringi)

parsed_cobs$plot <- unlist(stri_extract_all_regex(parsed_cobs$plot_treatment, pattern = "[0-9]+"))
parsed_cobs$treatment <- unlist(stri_extract_all_regex(parsed_cobs$plot_treatment, pattern = "[A-Z]+"))
```
The column "plot treatment" actually contained two pieces of information.  The plot was in numeric form (12,21,35,43,13,24,31,46,15,23,32) and the treatment was in the form of 1-2 letters representing continuous corn (CC), prairie (P), and fertilized prairie (PF).  Because of these forms, it was more challenging to parse, especially because there was no dividing agent within the cell.  So, I used a function regex, to extract certain components. First, extracting only numeric values, and placing them into their own column "plot". Second, I repeated the function, but selected the opposite (character) and placed this piece in its own column, "treatment".

## finalizing and selecting to form tidy subset
```{r}
tidy_cobs <- select(parsed_cobs, plot, treatment, sample_month:CO2_2012)
```
The final component of tidying this data included selecting all of the columns I wanted to be present within the subset. 

